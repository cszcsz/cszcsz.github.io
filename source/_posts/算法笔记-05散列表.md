---
title: 算法笔记-05散列表
date: 2019-11-19 09:32:02
categories: 数据结构与算法学习笔记
tags: [散列表]
keyword: 散列表
---

### 基本概念

- **散列表**(Hash Table)又叫哈希表，它通过散列函数将键值映射到表中的一个位置(数组下标)来访问对象。它的底层运用了数组支持下标随机访问的特性，基本上可以在O(1)的时间复杂度下完成查找、插入和删除操作。

- **散列函数**(Hash Function)又叫哈希函数，是一种从任何一种数据中创建小的"数字指纹"的方法，完成键值到散列值的映射，散列函数计算得到的散列值是一个非负整数。
- **散列冲突**，当存在key1≠key2而Hash(key1)=Hash(key2)的时候，称发生了散列冲突。
- **装载因子**，衡量散列表元素填充程度的指标，定义为（填入表中的元素个数 / 散列表长度），如果有n个元素放到了大小为m的散列表中，那么装载因子就为n/m。所以基于开放地址法来解决散列冲突的散列表装载因子不会大于1，而基于拉链法则可以大于1。**装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降**



<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/hashtable.png" width=600px height=400px> </img>

### 什么是好的散列函数

- 将键值映射得到的**散列值尽可能随机且分布均匀**。最完美的情况是不同的key对应的散列值都不一样，但几乎不可能
- **计算复杂度小**。过于复杂的计算会降低散列表的性能。

<br>

### 如何设计散列函数

常见的散列函数设计方法有：直接寻址法、除留余数法、数据分析法、平方取中法、折叠法、随机数法等。

举三个栗子：

- 直接寻址法：f(key)=key或f(key)=a*key+b。取键值或键值的某个线性函数值作为散列值。

- 除留余数法：f(key)=key mod p(p<=m)。例如对于英文单词"world"可以先逐位对字母的ASCII码进行求和，再将求和结果mod散列表的长度作为散列值。

- 数据分析法：对应手机号码这个key，分析可知手机号码后面几位的值比较随机，因此可以取手机号后四位作为散列值。

<br>

### 如何解决散列冲突

1. **开放寻址法**

   **核心思想**：如果出现了散列冲突，我们就重新探测一个空闲位置将其插入。开放地址法其中又包括线性探测、二次探测和双重散列。

   - 线性探测法

     插入：如果映射到的槽位已经存在元素(即发生了冲突)，我们就从这开始依次遍历下一个槽位直到找到一个空槽位进行插入。

     查找：从映射到的槽位开始逐一比较待查找元素的key值和槽内元素的key，如果相同则找到；若遍历到了一个空槽位则没有找到即不存在该元素。

     删除：不能直接把查找到的元素所在槽“清空”，否则会导致查找算法失效。每次删除一个元素，需要在该槽位添加一个"delete"标记，表示这是执行过删除操作的空槽位，当查找算法遍历到已标记的槽位不会退出，而是跳过该槽继续往下查找。

   - 二次探测

     顾名思义，不像线性探测法那样逐一遍历，而是以0<sup>2</sup>,1<sup>2</sup>,2<sup>2</sup>...这样的步长进行探测。

   - 双重散列

     意思是不用一个散列函数，而是使用一组散列函数hash1(key),hash2(key),hash3(key)...我们先用第一个散列函数，如果位置已被占用，再用第二个散列函数，依次类推。

   **优点**：数据都存在数组中，可以有效利用CPU缓存加快查找速度；序列化比较简单。

   **缺点**：删除操作比较麻烦；装载因子的上限不能太大，比拉链法更浪费存储空间。

   **适用场景**：当数据量小、装载因子小的时候。

   <!--more-->

2. **拉链法**

   **核心思想**：散列表中的每个”槽“都对应一个链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

   **优点**：当装载因子变大，即使变成10，只要散列值均匀，也就是链表长度变长而已，虽然效率下降，但比顺序查找还是快得多；存储大对象时，指针所占内存可忽略不计；更加灵活，支持更多的优化策略，比如用红黑树代替链表(可以避免散列表时间复杂度退化到O(n)，JAVA中的HashMap就是这样优化的)。

   **缺点**：链表中的结点是零散分布在内存中的，对CPU缓存不是很友好；存储小对象时，指针的额外空间开销不可忽略。

   **适用场景**：存储大对象、大数据量的散列表；需要支持更多优化策略的时候。

   <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/hashmap2.png" width=650px height=400px/>

<br>

### 装载因子过大怎么办

采用**动态扩容**的机制。针对数组的扩容，数据搬移比较简单。但针对散列表的扩容却要复杂一些，因为散列表的大小变了，数据的存储位置也变了，这时**需要通过散列函数重新计算每个数据的存储位置**。

要**避免**低效的**一次性扩容**，我们可以**将扩容操作穿插在插入操作**的过程中：

当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。 通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。 

<br>

### 散列表和链表、跳表的结合

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。

如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们可以将散列表和链表（或者跳表）结合在一起使用。