---
title: 算法笔记-09堆
date: 2019-11-26 17:01:18
categories: 数据结构与算法学习笔记
tags: [堆]
keyword: 堆
---

### 堆

堆是一种特殊的树，且满足以下两个条件：

- 堆是一个完全二叉树
- 堆中的每个节点的值都必须大于等于(或小于等于)其左右子节点的值

堆又分为最小堆(小顶堆)和最大堆(大顶堆)



### 堆的存储

由于堆是完全二叉树，所以一般用数组来存储。

若从数组下标为1的位置开始存储根节点，则左子节点下标为`2i`，右子节点下标为`2i+1`，节点的父节点则是`i/2`

若从数组下标为0的位置开始，则左子节点下标为`2i+1`，右子节点下标为`2i+2`，节点的父节点则是`(i-1)/2`

<br>

### 堆化(Heapify)

堆的构建、插入和删除操作背后涉及到堆化(heapify)的原理，其原理非常简单：**就是顺着节点所在路径，向上或者向下，对比，然后交换，使其满足堆的性质。**

最下堆的自上往下堆化代码实现：

```c++
void Heapify(int data[], int n, int i)      //最小堆自上而下堆化
{
    while (true)
    {
        int minPos = i;
        if (2 * i <= n && data[2 * i] < data[minPos])
            minPos = 2 * i;
        if (2 * i + 1 <= n && data[2 * i + 1] < data[minPos])
            minPos = 2 * i + 1;
        if (i == minPos)
            break;
        swap(data[i], data[minPos]);
        i = minPos;
    }
}
```

<br>

### 建堆(Build)

堆的构建过程如下：从第一个非叶子节点开始到根节点依次执行堆化操作

```c++
void BuildHeap(int a[], int n)
{
    for (int i = n / 2; i >= 1; i--)  // n为最后一个节点，n/2则为第一个非叶子节点
    {
        Heapify(a, n, i);
    }
}
```

<br>

### 向堆中插入一个元素(Insert)

原理:将待插入元素放到堆的末尾，然后从该节点开始自下而上堆化。时间复杂度：O(logn)，与堆的高度成正比。

注：一个包含n个节点的完全二叉树，树的高度不会超过log<sub>2</sub>n

```c++
void Insert(int x)
{
    data[++count] = x;       // count是堆中已存储数据的个数
    int i = count;
    while (i / 2 >= 1 && data[i] < data[i / 2])     // 以最小堆为例
    {
        swap(data[i], data[i / 2]);
        i /= 2;
    }
}
```

<br>

### 删除堆顶元素(Delete)

原理：把最后一个元素放到堆顶，然后从上往下堆化

```c++
bool DeleteMin()
{
    if(count==0) return false;
    a[1]=a[count--];
    Heapify(a, count, 1);
}
```

<br>

### 堆排序(Sort)

堆排序包含两个步骤：1. 建堆 2.排序

#### 建堆时间复杂度分析：

我们需要对`n/2`个节点进行堆化操作，每个节点堆化过程中需要比较和交换的节点个数跟这个节点的高度成正比。我们将每个节点的高度求和得到的就是建堆的时间复杂度：

`S = 1*h + 2*(h-1) + 4*(h-2) + 8*(h-3) +...+2^(n-1)*1  `

利用错位相减可得`S = 2^(h+1)-h-2`，又因为h=log<sub>2</sub>n，代入S可得`S=O(n)`

**所以建堆的时间复杂度是O(n)！**

#### 排序

排序操作类似与删除操作，我们把堆顶元素和最后一个元素互换，然后对剩下的n-1个元素进行堆化，重复这个过程，就完成了排序，时间复杂度为O(nlogn)。

```c++
void HeapSort(int a[], int n)
{
    BuildHeap(a, n);
    int k = n;
    while(k>1)
    {
        swap(a[k], a[1]);
        k--;
        Heapify(a, k, i);
    }
}
```

**综上：堆排序整体的时间复杂度为O(nlogn)，是原地排序，但不是稳定的排序算法（因为在排序的过程中存在将最后一个节点跟堆顶节点互换的操作，所以有可能改变值相同数据的原始相对顺序）**

<br>

### 堆排序vs快速排序

为什么在实际开发中**快速排序要比堆排序性能好**？

1. 快速排序是顺序访问数组的；而堆排序是跳着访问的，这样对CPU缓存不友好。

2. 对于同样的数据，在排序过程中，堆排序算法的交换次数可能要多于快速排序

   分析：快速排序数据的交换次数不会比**逆序度**多。但是堆排序的第一步是建堆，而建堆的过程会打乱原始数据的相对先后顺序，可能导致原有数据的有序度降低。比如对于一组有序数据，经过建堆之后反而无序了。

<br>

### 堆的应用

#### 应用一：优先级队列

- 合并有序小文件（多路归并）

  若每次从取出的n条数据顺序查找到最小值并放到大文件中中时间复杂度为O(n)。如果我们维护一个大小为n的最小堆，每次将堆顶元素放入大文件中并将其从堆中删除，然后再从小文件中取出下一条数据放入堆中。这样时间复杂度是O(logn)，比原来高效了很多。

- 高性能定时器

<br>

#### 应用二：求Top K问题

如何在一个包含n个数据的数组中查找前K大数据呢？

我们可以**维护一个大小为K的最小堆**(小顶堆)，顺序遍历数组（事先要用数组里的数填满堆），从数组中取出数据与堆顶比较。如果比堆顶元素大，我们就把堆顶元素删除，并且把这个元素插入堆中；如果比堆顶元素小，则什么也不做，继续遍历数组。这样遍历完后，堆中的数据就是前K大数据了。

遍历数组需要O(n)时间复杂度，一次堆化操作需要O(logk)的时间复杂度，所以最坏情况下每个元素都插入堆一次，**最坏时间复杂度就是O(nlogk)**

<br>

#### 应用三：求中位数

对于**动态数据集合**如果每次都是先排序，再求中位数，那效率不怎么高。借助堆，我们可以高效地求中位数。

我们**维护两个堆，一个最大堆，一个最小堆，最大堆存储前半部分数据，最小堆存储后半部分数据**，这样小顶堆中的数据都大于大顶堆中的数据。

举个栗子：假设有n个数据，我们从小到大排序，若n为奇数，那么前n/2+1个数据存储到最大堆中，后n/2个数据存储在最小堆中。**这样，最大堆中的堆顶元素就是我们要找的中位数**。

对于动态数据集合，如果新加入的数据小于等于最大堆的堆顶元素，就插入到最大堆中；否则插入到最小堆中。这时，如果两个堆的数据个数不符合前面的约定(不平衡)，我们可以从一个堆中不停的将堆顶元素移动到另一个堆上。

实际上，不仅可以利用两个堆来求中位数，进一步推广可以求其他**百分位的数据**，原理和求中位数一样。