---
title: 算法笔记-08红黑树
date: 2019-11-24 10:20:17
categories: 数据结构与算法学习笔记
tags: [红黑树]
keyword: 红黑树
---

### 2-3查找树

红黑树是一个实现非常复杂的高效动态数据结构，在学习红黑树前，非常有必要先引入2-3查找树。**红黑树是由2-3查找树演化而来的，可以说红黑树就是2-3查找树的一种实现方式。**

网络上的很多博客、资料在介绍红黑树时总是先摆出红黑树所满足的几个条件，然后就像“玩魔方”似的遇到特定情况就按公式进行“还原”以满足红黑树的几个条件。**但是，这种背公式的学习方式不出几天就忘的差不多了，想要真正的理解红黑树的原理，就必须<u>建立红黑树和2-3查找树的对应关系</u>。**

首先我们来看2-3查找树（有的地方也叫做2-3-4树）：

> 定义：一颗2-3查找树或为一棵空树，或由2-结点和3-结点组成的查找树

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/redblacktree1.png" height=40% width=40%/>

**一颗完美平衡的2-3查找树中的所有空链接到根结点的距离应该都是相同的。**

<br>

#### 2-3树的插入

2-3树的插入情况可以用一句话来概括：**遇到2-结点则将其插入变为3-结点；遇到3-结点则先临时变为4-结点再分解为两个2-结点并把中键移动到父节点中，就这样一直向上不断分解临时的4-结点并将中键插入更高层的父节点，若根结点最后为4-结点，则同样分解并且树的高度+1。**

情况1：向2-结点中插入新键

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124110408.png" height=50% width=50%/>

情况2：向只有一个3结点的树插入新键

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124110810.png" height=50% width=60%/>

情况3：向父节点为2-结点的3-结点插入新键

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124111300.png" height=50% width=60%/>

情况4：向父节点为3-结点的3-结点插入新键

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124111809.png" width=70% height=60%/>

<br>

### 红黑树

2-3树非常的平衡，任意空链接到根结点的路径长度都是相等的。**但是我们离真正的实现还有一段距离，这种直白的表示方法实现起来并不方便。**我们需要维护2-结点和3-结点，将一种数据类型转换为另一种等等，而它们所产生的开销可能会使算法比标准的二叉查找树更慢。

所以我们采取一种折中的方案，用红黑二叉查找树(红黑树)来实现2-3树。

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124113242.png" height=50% width=80%/>

**注意：我们说某个结点的颜色时，指的是指向该结点的链接颜色。**

红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：

- 根节点总为黑色（每次插入后都将根结点设为黑色；当根结点由红变黑时，树的**黑链接**高度就会加1）

- 红链接均为左链接（能够减少可能出现的情况，简化代码）
- 没有任何一个结点同时和两条红链接相连（对应2-3树中没有4-结点）
- 该树是**完美黑色平衡**的，即任意空链接到根结点的路径上的**黑链接数量相同**

满足这样定义的红黑树和相应的2-3树是一一对应的。**如果我们将由红链接相连的结点合并，得到的就是一棵2-3树。**

红黑树既是二叉查找树，也是2-3树，因此我们可以将两个算法的优点**结合**起来：**二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。**

<br>

#### 旋转、颜色转换

在进行红黑树插入操作前先理解几个基本操作：

- **左旋**（对某个结点执行**左旋操作**就是**向左旋转该结点的右子链接**，根结点互换。类似**旋转哑铃**！）

  <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124120647.png" width=90% height=50%/>

```c++
Node* rotateLeft(Node* h)
{
    Node* x = h->right;
    h->right = x->left;
    x->left = h;
    x->color = h->color;
    h->color = RED;
    return x;
}
```

-  **右旋**

  <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124121038.png" height=50% width=90%/>

```java
Node* rotateRight(Node* h)
{
    Node* x = h->left;
    h->left = x->right;
    x->right = h;
    x->color = h->color;
    h->color = RED;
    return x;
}
```

- **颜色转换**（等价于2-3树中分解4-结点并将中键移到父节点中的过程！！！）

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124121701.png" height=60% width=60%/>

```java
void flipColors(Node* h)
{
    h->color = RED;
    h->left->color = BLACK;
    h->right->color = BLACK;
}
```

<br>

#### 红黑树的插入

注意：红黑树插入的结点是红色的(即**用红色链接指向刚插入的结点**)，每次插入后都将根结点设为黑色。

与2-3树类似，红黑树的插入也有上述情况，一定要对应着2-3树的插入来理解红黑树的插入，这里概括为2种情况

**情况1：向2-结点插入新键**（类比2-3树向一个2-结点插入新键变为3-结点）

- 向左插入：什么也不做

  

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124152240.png" width=35% height=35%/>

- 向右插入：左旋（因为出现了红色右链接，我们规定红链接只能以左链接的形式存在）

  <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124152550.png" width="60%" height=50%/>

**情况2：向3-结点插入新键**（类比2-3树向一个3-结点插入新键，分解成两个2-结点并把中键向父节点传递）

- 向左插入(新键最小)：先右旋再颜色转换

  <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124153527.png" width="85%" height="50%"/>

- 向右插入(新键最大)：直接颜色转换

  <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124153953.png" width=85% height=50%/>

- 向中间插入(新键介于两者之间)：

  <img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191124154534.png" width=100% height=60%/>

**核心：要在一个3-结点下插入新键，先创建一个临时的4-结点，将其分解并将红链接由中间键传递给它的父节点。重复这个过程，我们就能将红链接在树中自下向上传递，直到遇到一个2-结点或根结点。**

总之，只要使用左旋转、右旋转、颜色转换这三个简单的操作，我们就能保证插入后红黑树和2-3树的一一对应关系。

在沿着插入点到根结点路径上移到时所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：

- 如果右子节点是红色的而左子节点是黑色的，进行左旋转
- 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转
- 如果左右子节点都是红色的，进行颜色转换

<!--more-->

<br>

#### 红黑树插入算法实现

```c++
Node* set(Node* h, Key key, Value val)     //C++的map容器就是用红黑树实现的
{
    if(h==nullptr)
        return new Node(key,val,RED);
    int cmp = key.compareTo(h.key);
    if(cmp<0) h->left = put(h->left,key,val);
    else if(cmp>0) h->right = put(h->right,key,val);
    else h.val = val;
    
    if(isRed(h->right) && !isRed(h->left)) h = rotateLeft(h);
    if(isRed(h->left) && isRed(h->left->left)) h = rotateRight(h);
    if(isRed(h->left) && isRed(h->right)) flipColors(h);
    
    return h
}
```

红黑树的删除操作比插入操作更复杂一点，这里就不说明了，详情可以看《算法》上的分析。

<br>

#### 红黑树的性质

- **一颗大小为N的红黑树高度不会超过2lgN**

  红黑树的**最差情况**是它所对应的2-3树左边的路径结点全是3-结点而其余均为2-结点。这样将3-结点展开用红链接+两个2-结点表示的话，最左边的路径长度是只包含2-结点路径长度(lgN)的两倍，即2lgN。

- **红黑树中查找、插入、删除等操作最坏情况下所需时间是对数级别的，即O(logN)**

- **红黑树支持有序性的操作**（因为红黑树也是二叉查找树嘛~）

<br>

#### 红黑树 VS AVL树

- 红黑树的查询性能略微逊色于AVL树。(AVL树高度平衡，最多存在1层的高度差；而红黑树最坏情况存在lgN的高度差)

- 红黑树在插入和删除上优于AVL树。(AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多)
-  **红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强** 