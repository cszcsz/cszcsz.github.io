---
title: python核心-赋值、浅拷贝、深拷贝、参数传递
date: 2019-12-06 19:02:26
categories: python
keyword: 赋值、浅拷贝、深拷贝、函数参数传递
---

首先总结一下Python中的**核心**：

- Python中一切都是对象，对象拥有自己的内存空间、地址(id)、类型等信息
- Python中的变量没有类型，可以理解为就是个标签(引用)
- Python中给变量赋值就相当于把标签贴到相应的对象上
- Python中函数参数的传递和返回实质就是赋值的过程
- 在 Python 中，可变对象包括 list、dict、set、自定义类型等；不可变对象包括 int、float、bool、str、tuple 等
- 浅拷贝仅仅只拷贝了一层，即拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用
- 深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。

### 赋值

**Python里给某个变量赋值，就像把标签贴到相应的对象上。**而不像C++：变量拥有自己的类型和内存空间，此时变量就像个“容器”，给变量赋值就像把值放到这个容器里，再次赋值就是把容器里的数据替换掉。不能用C++中的赋值来理解Python中的赋值！

```python
# 赋值知识点考察小demo(先不看输出，检验自己是否真的理解了)
a = 1
print('a',a,id(a))
b = 2
print('b',b,id(b))
c = 1
print('c',c,id(c))
a = b
print('a',a,id(a))	
```

```
输出：
a 1 4301490544
b 2 4301490576
c 1 4301490544  # 因为数字对象是不可变的，为了提高效率，python会使用一些公用的对象
a 2 4301490576
```

<br>

### 函数参数传递

**Python里的参数是通过赋值传递的**

```python
# demo
def fun(a):
    a[0] = 10
    a = [4,5,6]
    return m
l = [1,2,3]
fun(l)
print('l=',l)
```

```
输出：
l= [10,2,3]
```

很多地方将 Python 中的函数参数传递分为可变对象和不可变对象来说明，然后类比到 C++ 的值传递和引用传递，这样理解是相当不好的！

<br>

### 可变对象和不可变对象

在 Python 中，

**可变对象**包括 **list、dict、set、自定义类型**等；
**不可变对象**包括 **int、float、bool、str、tuple** 等。

不可变对象不允许对自身内容进行修改。如果我们对一个不可变对象进行赋值，实际上是生成一个新对象，再让变量指向这个对象。

两者在功能上的最大区别就是：**不可变对象可以作为字典 dict 的键 key，而可变对象不行**。比如 list 不能作为字典的键，但 tuple 可以。

```python
# demo
s = 'csz'    # 字符串是不可变对象
s2 = s.replace('z','s')
print('s',s)
print('s2',s2)
l = [1,2,3]  # 列表是可变对象
l2 = l.reverse()
print('l',l)
print('l2',l2)
```

```
输出：
s csz
s2 css
l [3,2,1]
l2 None
```

解释：因为 `str` 是不可变对象，所以它的方法如 `replace`、`strip`、`upper` 都不可能修改原对象，**只会返回一个新对象**。而 `list` 是可变对象，它的方法如 `reverse`、`sort`、`append`，都是**在原有对象上直接修改**，无返回值。

但是要注意一个列外：`l = l +` 和 `l +=` 虽然是一样的结果，但 l 指向的对象却发生了变化。原因在于，前者是做了赋值操作，而后者其实是调用的 `__iadd__` 方法。

<br>

### 浅拷贝和深拷贝

**浅拷贝**: 创建新对象，其内容是原对象的引用。浅拷贝之所以称为浅拷贝，是**它仅仅只拷贝了一层，拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用**而已。

**深拷贝**：深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。深拷贝出来的对象是一个全新的对象，**不再与原来的对象有任何关联**。

浅拷贝有**三**种形式：**切片操作，工厂函数，copy模块中的copy函数**

如：切片操作：lst1=lst[:] 或 lst1 = [x for x in lst]；工厂函数：lst1=list(lst)；copy函数：lst1=copy.copy(lst)

深拷贝只有**一**种形式：**copy模块中的deepcopy函数**

如：lst1=copy.deepcopy(lst)

注意：

- 不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。
- 深拷贝的实现过程并不是完全的递归，否则如果对象的某级子元素是它自身的话，这个过程就死循环了。实际上，如果遇到已经处理过的对象，就会直接使用其引用，而不再重复处理。

```python
# demo1
a = [1,2,[3]]
b = a[:]    # 切片操作相当于浅拷贝
b[1] = 4
b[2][0] = 5
print(a)
```

```
输出：
[1,2,[5]]
```

```python
# demo2
from copy import deepcopy
a = [3,4]
b = [1,2,a,[5,a]]
c = deepcopy(b)
c[3][1][0] = -1
print(c)
```

```
输出：
[1,2,[-1,4],[5,[-1,4]]]
```

总结一下：

1. 外层添加元素时，浅拷贝不会随原列表变化而变化；内层添加元素时，浅拷贝才会变化。
2. 无论原列表如何变化，深拷贝都保持不变。
3. 赋值对象随着原列表一起变化。

<br>

### 全局变量和局部变量

```python
# demo
def fun(x):
    print('x=',x)
    y = 5
    x += y
    print('x=',x)
    return x

x = 5
fun(x)
print('x=',x)
```

```
输出：
x=5
x=10
x=5
```

若想在函数内部修改函数外部的变量，需要加上`global`关键字声明：

```python
# demo2
def fun():   
    global x   #这种情况下,x不能作为形参出现
    x = 10
x = 5
fun()
print('x=',x)
```

```
输出：
x=10
```

如果仅需要在函数内部读取外部变量的值，则不需要`global`声明

```python
# demo3
def fun():
    y = x
    print('y=',y)
x = 5
fun()
print('x=',x)
```

```
输出：
y=5
x=5
```

**写入的时候 ，`global` 的用于区分全局变量和局部变量，而读取不存在这样的问题**