---
title: 算法笔记-11字符串匹配算法
date: 2019-12-03 08:29:23
categories: 数据结构与算法学习笔记
keywords: 字符串匹配,BF,RK,BM,KMP
---

## BF算法

BF是Brute Force的缩写，即暴力匹配算法

#### **算法思想**

我们在主串中考查起始下标从0、1、2...n-m开始且长度为m的n-m+1个子串，看它们是否有跟模式串匹配的。（考察某一子串和模式串是否匹配的方法是逐一字符比较）

#### **时间复杂度分析**

举个栗子，若主串为aaaaaa，模式串为aab。那么每次都要对比模式串中的m个字符，要对比n-m+1次，**所以这种算法的最坏情况下的时间复杂度是O(n*m)。**

#### **应用**

尽管BF算法时间复杂度比较高，但在实际的项目它却是一个比较常用算法。为啥呢？原因主要有以下两点：1.实际的软件开发中，主串和模式串的长度都不会太长；另外，在统计意义上，大部分情况下的算法执行效率比O(n*m)高。2.朴素字符串匹配算法思想和实现都很简单，意味着不容易出错，符合KISS(Keep it Simple and Stupid)设计原则。

#### **实现**

```c++
// BM算法，暴力匹配，朴素算法，O(n*m)
int Serach(String txt,String pat)
{
    int N = txt.length();
    int M = pat.length();
    for(int i=0;i<N-M;i++)
    {
		for(int j=0;j<M;j++)
        {
            if(txt[i+j]!=pat[j])
                break;
        }
        if(j==M)
            return i;
    }
    return -1;
}
```

<br>

## RK算法

RK是Rabin-Karp这两位发明人名字的简写。本质上是BF算法的升级版，引入了**哈希算法**。

#### **算法思想**

通过哈希算法对主串中的n-m+1个长度为m的字串求哈希值，用它们的哈希值去和模式串的哈希值比较，如果某个字串的哈希值与模式串的相等，那就说明对应的字串和模式串匹配了。

#### **哈希函数的设计**

RK算法要求哈希算法设计的比较精巧，如果求每个子串的哈希值时都要遍历一次子串就太耗时了，这样反而得不偿失了，我们需要找到两个相邻子串哈希值的关系，用递推的方式一遍求出n-m+1个子串的哈希值。举个栗子：对于包含英文小写字母的字符串`cba`，我们将a~z映射到整数0~25，这样“cba”的哈希值就是'c'×26<sup>2</sup>+b×26+a=2*×26<sup>2</sup>+1×26+0=1353。就是用二十六进制来表示一个字符串，该二十六进制的十进制值就是哈希值。

#### **时间复杂度分析**

第一部分，求n-m+1个子串的哈希值只需要扫描一遍主串就可以了，时间复杂度为O(n)；第二部分，模式串哈希值与每个子串的哈希值比较的时间复杂度是O(1)，总共需要比较n-m+1次，所以这部分时间复杂度也是O(n)。**所以RK算法整体的时间的复杂度是O(n)。**

<br>

## BM算法

BM算法一种非常高效的字符串匹配算法，它的性能是KMP算法的3~4倍，BM算法本质上是寻找某种规律，看能不能让模式串一次往后滑动好几位。BM算法的匹配顺序与另外几个算法不同，它是按照模式串下标从大到小的顺序，**倒着匹配**的。

#### **坏字符规则**

当遇到不匹配的字符时，称**主串中**对应位置的字符为**坏字符**（bad character）。基本思想：当发生不匹配时，我们记坏字符在模式串中对应的下标为S<sub>i</sub>，坏字符若在模式串中存在，则把坏字符在模式串中的下标记为X<sub>i</sub>，若不存在则为-1。那么，模式串向后移动的位数为S<sub>i</sub>-X<sub>i</sub>。如果坏字符在模式串中出现多次，则选择靠后的那一个。**注意：**单纯使用坏字符规则还不够，因为S<sub>i</sub>-X<sub>i</sub>可能是负数，如：主串:`aaaaaaa`，模式串:`baaa`，所以BM算法还要用到好后缀规则。

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191204195243.png" width="60%"/>

#### 好后缀规则

好后缀规则原理与坏字符处理方法类似，当我们遇到不匹配的字符时，我们在模式串中从后向前寻找第一个与好后缀匹配的子串，然后我们将模式串向后移动使它们对齐，如下图所示：

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191204200405.png" width="60%"/>

若找不到，则会出现以下情况：

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191204202008.png" width="60%"/>

如图，**若一次性将模式串移动到好好后缀的后面(左分支)，则会出现错过正确匹配的情况**，显然这样移动过头了。我们知道在这种情况下，当主串中的好后缀与模式串重合时，肯定不能匹配。但一次性移动过头使之完全不重合又有可能错过匹配的情况。**所以，折中起来就是要移动模式串，使主串中的好后缀与模式串存在部分重合！**

**所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。**	

现在，坏字符规则和好后缀规则已经清楚了，那么我们到底是选择哪个作为移动的方案呢？我**们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数**。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。

#### 时间复杂度分析

BM算法在最好情况下的时间复杂度是很低的，只有O(n/m)。比如：主串为`aabaabaaa`，模式串为`aaa`，那么每次模式串都向后移动m位。

#### 代码实现

我们如何查找坏字符在模式串中的位置呢？如果我们每次拿坏字符在模式串中顺序查找，这样势必很慢，会影响匹配效率。想要更高效的查找，就得用到我们的散列表了。我们可以将模式串中的字符和对应的下标存在散列表中。比如我们创建一个大小为256的数组`bc[256]`，数组下标对应字符的ASCII码值，数组的值为对应的下标(若有重复字符则存靠后的下标)。

```c++
// 用hash表存坏字符下标
void initBC(String pat,int bc[])
{
    int m = pat.length();
    for(int i=0;i<sizeof(bc)/sizeof(int);i++)
    	bc[i] = -1;
    for(int i=0;i<m;i++)
    {
        int ascii = (int)pat[i];
        bc[ascii] = i;
    }
}
```

```c++
// 不考虑好后缀规则的代码
int BM(String txt,String pat)
{
    int n = txt.length();
    int m = pat.length();
    int i = 0;
    while(i<=n-m)
    {
		int j;
        for(j=m-1;j>=0;j--)
            if(txt[i+j]!=pat[j])
                break;
        if(j<0)
            return i;
        // 等同于将模式串往后滑动j-bc[(int)a[i+j]]位
        i = i + (j - bc[(int)txt[i+j]]);
    }
    return -1;
}
```

关于引入好后缀的算法实现这里先不写了，它还需要引入suffix和prefix数组。来完成以下任务

1. 在模式串中，查找跟好后缀匹配的另一个子串；

2. 在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；

<br>

## KMP算法

KMP算法是大家耳熟能详的算法，但总是学了就忘，所以我想简明扼要地把它的算法原理记录下来供以后回顾，KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的。

#### **算法思想**

其思想与BM算法类似，朴素的字符串查找算法不匹配时每次只将模式串向后移动一位，而KMP算法试图利用已匹配的字符，当发生某个字符不匹配时能够**将模式串向后多移动多位，跳过那些肯定不能匹配的情况，且主串不回退。**

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191204161525.png" width="70%" height="100%"/>

如图，当出现某个字符不匹配时，j回退到哪呢？（或者说模式串向后移到几位呢？）利用已经匹配到的信息，我们将j回退到**好前缀的最长可匹配前缀子串的末尾字符的下标位置**。那么，如何来求好前缀的最长可匹配前缀和后缀子串呢？其实这个问题其实不涉及主串，只需要通过模式串本身就能求解。所以，我们能不能事先预处理计算好，在模式串和主串匹配的过程中，直接拿过来就用呢？当然可以，这就要引入next数组了。

#### **next数组**

也叫失效函数，**数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的<u>最长</u>可以匹配<u>前缀子串</u>的结尾字符下标**。举个栗子如图：

<img src="https://raw.githubusercontent.com/cszcsz/BlogCloudImg/master/surfaceimg/20191204163537.png" width="70%" height="10%"/>

#### **next数组的求法**

我们利用数学归纳法的思想，初始化next[0]=-1，这个显而易见。如果我们知道next[i-1]，如何求next[i]呢？如果next[i-1]=k-1(即子串pat[0...k-1]是pat[0...i-1]的最长可匹配前缀子串)，这时若pat[k]=pat[i]，那么pat[0...k]就是pat[0...i]的最长可匹配前缀子串，即next=[i]=next[i-1]+1;若pat[k]≠pat[i]呢？这时我们就要找pat[0...i-1]的次长可匹配前缀子串，直到找到一个可匹配的且该串的下一个字符等于pat[i]就可以了。

#### **时间复杂度分析**

**KMP 算法的时间复杂度就是 O(m+n)，空间复杂度是O(m)。**

#### **代码实现**

```c++
// KMP匹配代码
int KMP(String txt,String pat)
{
    int n = txt.length();
    int m = pat.length();
    int j = 0;
    for(int i=0;i<n;i++)
    {
        while(txt[i]!=pat[j] && j>0)
            j = next[j-1] + 1;
        if(txt[i]==pat[j])
            j++;
        if(j==m)
            return i-m+1;
    }
    return -1;
}

// 求next数组
int* getNext(String pat)
{
    int m = pat.length();
    int* next = new int[m];
    next[0] = -1;
    int k = -1;
    for(int i=1;i<m;i++)
    {
        while(pat[k+1]!=pat[i] && k!=-1)
            k = next[k];
        if(pat[k+1]==pat[i])
            k++;
        next[i] = k;
    }
    return next;
}
```



