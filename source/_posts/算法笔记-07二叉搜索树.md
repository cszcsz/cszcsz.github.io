---
title: 算法笔记-07二叉搜索树
date: 2019-11-21 16:14:08
categories: 数据结构与算法学习笔记
tags: [二叉搜索树]
keyword: 二叉搜索树
---

### 二叉树的存储方式

- 基于指针或者引用的二叉**链式存储**法

- 基于数组的**顺序存储**法

  （此法比较适合存储完全二叉树，根节点从下标1开始存，左、右子节点分别在2i和2i+1的位置）



### 二叉搜索树

又叫二叉查找树或二叉排序树，其定义为在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

重要特性：按**中序遍历**二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。 

支持**重复数据**的二叉查找树：

-  二叉查找树中每一个节点不仅只存储一个数据，我们使用链表和支持动态扩容的数组等数据结构，**把值相同的数据都存储在同一个节点上** 
- 每个节点仍只存储一个数据，但插入相同数据的时候**当作大于这个节点**来处理

二叉查找树不管是插入、删除还是查找，时间复杂度都与树的**高度**成正比即O(height)。 平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn) 。

<br>

### AVL树

**AVL树**是最早被发明的[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的[时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度)都是![O(\log{n})](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)。增加和删除元素的操作则可能需要借由一次或多次[树旋转](https://zh.wikipedia.org/wiki/树旋转)，以实现树的重新平衡。 

需要对以下四种情况执行平衡操作(旋转)：LL,LR,RL,RR

其实现则是在普通的二叉搜索树插入、删除操作完成后增加平衡的代码：

```c++
template <class T>
AVLTreeNode<T>* AVLTree<T>::add(AVLTreeNode<T>* &tree, T data){
    if (tree == NULL) {
        tree = new AVLTreeNode<T>(data, NULL, NULL);
    }
    else if (data < tree->data){ 
        //将新加入的节点插入左子树 
        tree->Left = add(tree->Left, data);
        //检查加入新的结点之后树是否失去平衡 
        if (height(tree->Left) - height(tree->Right) == 2)
        {
            if (data < tree->Left->data)
                tree = LL_Rotation(tree);//左左，新加入之后左儿子的左儿子深了  
            else
                tree = LR_Rotation(tree);//左右，新加入之后左儿子的右儿子深了
        }
    }
    //将新加入的节点插入右子树 
    else if (data > tree->data) {
        tree->Right = add(tree->Right, data);
        //检查加入新的结点之后树是否失去平衡 
        if (height(tree->Right) - height(tree->Left) == 2)
        {
            if (data > tree->Right->data)
                tree = RR_Rotation(tree);//右右，新加入之后右儿子的右儿子深了  
            else
                tree = RL_Rotation(tree);//右左，新加入之后右儿子的左儿子深了  
        }
    }
    else //该节点已经在树中 
    {
        cout << "该节点已经存在树中" << endl;
    }
    //更新更前当前节点的高度 
    tree->height = max( height(tree->Left), height(tree->Right)) + 1;

    return tree;
}
```



<br>

### 平衡的二叉搜索树 VS 散列表

二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？ 

1.  散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列 
2.  散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定。我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。 
3.  尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
4.  散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 

**综上所述，平衡二叉搜索树在某些方面还要优于散列表，这两者并不冲突，我们需要结合实际的情况和需求来选择**

<!--more-->

### 附：二叉搜索树的C++实现

```c++
class Node
{
public:
    int data;
    Node *lch, *rch;
    Node(int x) : data(x), lch(nullptr), rch(nullptr) {}
};

class BinarySearchTree
{
public:
    Node *root;

public:
    BinarySearchTree() = default;
    ~BinarySearchTree() { DestoryTree(root); }
    void Insert(int x, Node *&r);
    bool Find(int x, Node *r);
    bool Delete(int x);
    int GetHeight(Node *r);
    void InOrder(Node *r);
    void PreOrder(Node *r);
    void PostOrder(Node *r);
    void LevelOrder();
    void DestoryTree(Node *r);
};

void BinarySearchTree::DestoryTree(Node *r)
{
    if (r == nullptr)
        return;
    DestoryTree(r->lch);
    DestoryTree(r->rch);
    delete r;
}

void BinarySearchTree::InOrder(Node *r)
{
    if (r == nullptr)
        return;
    InOrder(r->lch);
    cout << r->data << " ";
    InOrder(r->rch);
}
void BinarySearchTree::PreOrder(Node *r)
{
    if (r == nullptr)
        return;
    cout << r->data << " ";
    PreOrder(r->lch);
    PreOrder(r->rch);
}

void BinarySearchTree::PostOrder(Node *r)
{
    if (r == nullptr)
        return;
    PostOrder(r->lch);
    PostOrder(r->rch);
    cout << r->data << " ";
}

void BinarySearchTree::LevelOrder()
{
    queue<Node *> q;
    q.push(root);
    while (!q.empty())
    {
        Node *top = q.front();
        cout << top->data << " ";
        if (top->lch != nullptr)
            q.push(top->lch);
        if (top->rch != nullptr)
            q.push(top->rch);
        q.pop();
    }
}

int BinarySearchTree::GetHeight(Node *r)
{
    if (r == nullptr)
        return 0;
    else
        return max(GetHeight(r->lch), GetHeight(r->rch)) + 1;
}

void BinarySearchTree::Insert(int x, Node *&r)
{
    if (r == nullptr)
        r = new Node(x);
    else if (x < r->data)
        Insert(x, r->lch);
    else
        Insert(x, r->rch);
}

bool BinarySearchTree::Find(int x, Node *r)
{
    if (r == nullptr)
        return false;
    if (r->data == x)
        return true;
    else if (r->data < x)
        Find(x, r->rch);
    else
        Find(x, r->lch);
}

bool BinarySearchTree::Delete(int x)      // 删除操作是二叉搜索树的重点和难点！！！
{
    Node *p = root, *pp = nullptr;
    //先找到待删除的节点并记录其父节点
    while (p != nullptr && p->data != x)
    {
        pp = p;
        if (p->data > x)
            p = p->lch;
        else
            p = p->rch;
    }
    if (p == nullptr)
        return false;
    //情况1：待删除节点有两个子节点
    if (p->lch != nullptr && p->rch != nullptr)
    {
        Node *tmpMinp = p->rch, *tmpMinpp = p;
        while (tmpMinp->lch != nullptr)
        {
            tmpMinpp = tmpMinp;
            tmpMinp = tmpMinp->lch;
        }
        p->data = tmpMinp->data; // 令待删除节点的值为其右子树上的最小值
        p = tmpMinp;             // 再删除该右子树最小值节点，巧妙的转化为情况2
        pp = tmpMinpp;
    }
    //情况2：待删除节点是叶子节点或只有一个子节点
    Node *child;
    if (p->lch != nullptr)
        child = p->lch;
    else if (p->rch != nullptr)
        child = p->rch;
    else
        child = nullptr;
    if (pp == nullptr) //如果删除的是根节点
        root = child;
    else
    {
        if (pp->lch == p)
            pp->lch = child;
        else if (pp->rch == p)
            pp->rch = child;
        delete p;
    }
    return true;
}
```

