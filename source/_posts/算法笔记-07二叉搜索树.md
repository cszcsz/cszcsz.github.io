---
title: 算法笔记-07二叉搜索树
date: 2019-11-21 16:14:08
categories: 数据结构与算法学习笔记
tags: [二叉搜索树]
keyword: 二叉搜索树
---

### 二叉树的存储方式

- 基于指针或者引用的二叉**链式存储**法

- 基于数组的**顺序存储**法

  （此法比较适合存储完全二叉树，根节点从下标1开始存，左、右子节点分别在2i和2i+1的位置）



### 二叉搜索树

又叫二叉查找树或二叉排序树，其定义为在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

重要特性：按**中序遍历**二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。 

支持**重复数据**的二叉查找树：

-  二叉查找树中每一个节点不仅只存储一个数据，我们使用链表和支持动态扩容的数组等数据结构，**把值相同的数据都存储在同一个节点上** 
- 每个节点仍只存储一个数据，但插入相同数据的时候**当作大于这个节点**来处理

二叉查找树不管是插入、删除还是查找，时间复杂度都与树的**高度**成正比即O(height)。 平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn) 。



### 平衡的二叉搜索树 VS 散列表

二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？ 

1.  散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列 
2.  散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定。我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。 
3.  尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
4.  散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 

**综上所述，平衡二叉搜索树在某些方面还要优于散列表，这两者并不冲突，我们需要结合实际的情况和需求来选择**

<!--more-->

### 二叉搜索树的C++实现

```c++
class Node
{
public:
    int data;
    Node *lch, *rch;
    Node(int x) : data(x), lch(nullptr), rch(nullptr) {}
};

class BinarySearchTree
{
public:
    Node *root;

public:
    BinarySearchTree() = default;
    ~BinarySearchTree() { DestoryTree(root); }
    void Insert(int x, Node *&r);
    bool Find(int x, Node *r);
    bool Delete(int x);
    int GetHeight(Node *r);
    void InOrder(Node *r);
    void PreOrder(Node *r);
    void PostOrder(Node *r);
    void LevelOrder();
    void DestoryTree(Node *r);
};

void BinarySearchTree::DestoryTree(Node *r)
{
    if (r == nullptr)
        return;
    DestoryTree(r->lch);
    DestoryTree(r->rch);
    delete r;
}

void BinarySearchTree::InOrder(Node *r)
{
    if (r == nullptr)
        return;
    InOrder(r->lch);
    cout << r->data << " ";
    InOrder(r->rch);
}
void BinarySearchTree::PreOrder(Node *r)
{
    if (r == nullptr)
        return;
    cout << r->data << " ";
    PreOrder(r->lch);
    PreOrder(r->rch);
}

void BinarySearchTree::PostOrder(Node *r)
{
    if (r == nullptr)
        return;
    PostOrder(r->lch);
    PostOrder(r->rch);
    cout << r->data << " ";
}

void BinarySearchTree::LevelOrder()
{
    queue<Node *> q;
    q.push(root);
    while (!q.empty())
    {
        Node *top = q.front();
        cout << top->data << " ";
        if (top->lch != nullptr)
            q.push(top->lch);
        if (top->rch != nullptr)
            q.push(top->rch);
        q.pop();
    }
}

int BinarySearchTree::GetHeight(Node *r)
{
    if (r == nullptr)
        return 0;
    else
        return max(GetHeight(r->lch), GetHeight(r->rch)) + 1;
}

void BinarySearchTree::Insert(int x, Node *&r)
{
    if (r == nullptr)
        r = new Node(x);
    else if (x < r->data)
        Insert(x, r->lch);
    else
        Insert(x, r->rch);
}

bool BinarySearchTree::Find(int x, Node *r)
{
    if (r == nullptr)
        return false;
    if (r->data == x)
        return true;
    else if (r->data < x)
        Find(x, r->rch);
    else
        Find(x, r->lch);
}

bool BinarySearchTree::Delete(int x)      // 删除操作是二叉搜索树的重点和难点！！！
{
    Node *p = root, *pp = nullptr;
    //先找到待删除的节点并记录其父节点
    while (p != nullptr && p->data != x)
    {
        pp = p;
        if (p->data > x)
            p = p->lch;
        else
            p = p->rch;
    }
    if (p == nullptr)
        return false;
    //情况1：待删除节点有两个子节点
    if (p->lch != nullptr && p->rch != nullptr)
    {
        Node *tmpMinp = p->rch, *tmpMinpp = p;
        while (tmpMinp->lch != nullptr)
        {
            tmpMinpp = tmpMinp;
            tmpMinp = tmpMinp->lch;
        }
        p->data = tmpMinp->data; // 令待删除节点的值为其右子树上的最小值
        p = tmpMinp;             // 再删除该右子树最小值节点，巧妙的转化为情况2
        pp = tmpMinpp;
    }
    //情况2：待删除节点是叶子节点或只有一个子节点
    Node *child;
    if (p->lch != nullptr)
        child = p->lch;
    else if (p->rch != nullptr)
        child = p->rch;
    else
        child = nullptr;
    if (pp == nullptr) //如果删除的是根节点
        root = child;
    else
    {
        if (pp->lch == p)
            pp->lch = child;
        else if (pp->rch == p)
            pp->rch = child;
        delete p;
    }
    return true;
}
```

