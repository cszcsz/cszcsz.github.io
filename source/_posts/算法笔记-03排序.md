---
title: 算法笔记-03排序
date: 2019-11-16 19:42:41
categories: 数据结构与算法学习笔记
tags: [排序]
keyword: 排序
---

## 1. 排序算法

### 1.1 总结表

| 排序算法 |  平均时间复杂度  |     最好情况     |     最坏情况     | 空间复杂度 | 稳定性 | 排序方式  |
| :------: | :--------------: | :--------------: | :--------------: | :--------: | :----: | :-------: |
| 冒泡排序 | O(n<sup>2</sup>) |       O(n)       | O(n<sup>2</sup>) |    O(1)    |  稳定  | in-place  |
| 选择排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |    O(1)    | 不稳定 | in-place  |
| 插入排序 | O(n<sup>2</sup>) |       O(n)       | O(n<sup>2</sup>) |    O(1)    |  稳定  | in-place  |
| 归并排序 |     O(nlogn)     |     O(nlogn)     |     O(nlogn)     |    O(n)    |  稳定  | out-place |
| 快速排序 |     O(nlogn)     |     O(nlogn)     | O(n<sup>2</sup>) |  O(logn)   | 不稳定 | in-place  |
|  堆排序  |     O(nlogn)     |     O(nlogn)     |     O(nlogn)     |    O(1)    | 不稳定 | in-place  |
|  桶排序  |      O(n+k)      |      O(n+k)      | O(n<sup>2</sup>) |   O(n+k)   |  稳定  | out-place |
| 计数排序 |      O(n+k)      |      O(n+k)      |      O(n+k)      |    O(k)    |  稳定  | out-place |
| 基数排序 |      O(n*k)      |      O(n*k)      |      O(n*k)      |   O(n+k)   |  稳定  | out-place |

  注：排序方式in-place意思是原地排序，与内部排序和外部排序(数据存储在外部磁盘中，无法一次全部加载到内存中)的概念不同。



  

### 1.2各类排序算法实现

#### **冒泡排序**：

C++实现：

```c++
// 1.冒泡排序
// 时间复杂度:最好-O(n),最坏-O(n^2)，平均-O(n^2)  
// 空间复杂度:O(1)
// 稳定排序
void BubbleSort(int nums[],int n)
{
    bool flag;
    for(int i=0;i<n;i++)
    {
        flag=true;
        for(int j=0;j<n-i-1;j++)
        {
            if(nums[j]>nums[j+1])
            {
                flag=false;
                int temp = nums[j];
                nums[j]=nums[j+1];
                nums[j+1]=temp;
            }
        }
        if(flag)
            break;
    }
}
```

Python实现：

```python
def BubbleSort(data):
    length = len(data)
    for i in range(length):
        for j in range(length-i-1):
            if data[j]>data[j+1]:
                data[j+1],data[j] = data[j],data[j+1]
```

  

  





#### **选择排序**：

 C++实现：

```c++
// 2.选择排序
// 时间复杂度:最好-O(n^2),最坏-O(n^2)，平均-O(n^2)  
// 空间复杂度:O(1)
// 不稳定排序
void SelectSort(int nums[],int n)
{
    for(int i=0;i<n;i++)
    {
        int tempMin=nums[i],index=i;
        for(int j=i+1;j<n;j++)
        {
            if(nums[j]<tempMin)
            {
                tempMin=nums[j];
                index=j;
            }
        }
        nums[index]=nums[i];
        nums[i]=tempMin;
    }
}
```

Python实现：

```python
def SelectSort(data):
    length=len(data)
    for i in range(length):
        tempMin,index=data[i],i
        for j in range(i+1,length):
            if data[j]<tempMin:
                tempMin=data[j]
                index=j
        data[index]=data[i]
        data[i]=tempMin
```

  

  




#### 插入排序

C++实现：

```c++
// 2.插入排序
// 时间复杂度:最好-O(n),最坏-O(n^2)，平均-O(n^2)  
// 空间复杂度:O(1)
// 稳定排序
void InsertSort(int nums[],int n) 
{
    // 初始化：假定一个元素是已排序区间，之后的元素为未排序区间
    for(int i=1;i<n;i++)
    {
        int tmp = nums[i],j;
        for(j=i-1;j>=0;j--)
        {
            if(tmp>=nums[j])
                break;
            else
                nums[j+1]=nums[j];
        }
        nums[j+1]=tmp;
    }
}
```

Python实现：

```python
def InsertSort(data):
    length=len(data)
    for i in range(1,length):
        temp=data[i]
        for j in range(i-1,-1,-1):
            if temp>data[j]:
                break
            else:
                data[j+1]=data[j]
        data[j+1]=temp
```

  

  




#### 归并排序

C++实现：

```c++
// 4.归并排序
// 时间复杂度：所有情况下都是O(nlogn)
// 空间复杂度：每次归并需要开辟一个临时数组然后释放，所以是O(n)
// 稳定性：稳定
// 递推式：sort(p,q) = merge(sort(p,r),sort(r+1,q))  边界条件:p>=q
void MergeSortR(int nums[],int p,int q)
{
    if(p>=q)
        return;
    int r = (p+q)/2;
    MergeSortR(nums,p,r);
    MergeSortR(nums,r+1,q);
    Merge(nums,p,q,r);
}

//把nums[p...r]和nums[r+1,q]合并到nums[p...q]
void Merge(int nums[],int p,int q,int r)
{
    int n=q-p+1,i=p,j=r+1,k=0;
    int *tmp = new int[n];
    //二路归并
    while (i<=r&&j<=q)
    {
        if(nums[i]<=nums[j])
            tmp[k++]=nums[i++];
        else
            tmp[k++]=nums[j++];
    }
    //把其中一个剩余的数组中的数搬到临时数组中
    int start=i,end=r;
    if(j<=q)
    {
       start=j;
       end=q;  
    }
    while (start<=end)
        tmp[k++]=nums[start++];
    //将tmp临时数组拷贝回nums数组
    for(int t=0;t<=q-p;t++)
        nums[p+t]=tmp[t];
    delete tmp;
}

void MergeSort(int nums[],int n)
{
    MergeSortR(nums,0,n-1);
}
```

  

  




#### 快速排序

C++实现:

```c++
// 5.快速排序
// 时间复杂度：最坏(数组逆序):O(n^2),平均(大多数情况):O(nlogn)
// 空间复杂度：O(1)
// 稳定性：不稳定
// 递推式：sort(A[p..q]) = sort(A[p..r-1])+sort(A[r+1..q]) 终止条件:p>=q
void QuickSortR(int nums[],int p,int q)
{
    if(p>=q)
        return;
    int r=Partition(nums,p,q);
    QuickSortR(nums,p,r-1);
    QuickSortR(nums,r+1,q);
}

int Partition(int nums[],int p,int q)
{
    int val=nums[q],i=p,j=p;
    for(;i<q;i++)
    {
        if(nums[i]<=val)
        {
            int temp=nums[i];
            nums[i]=nums[j];
            nums[j]=temp;
            j++;
        }
    }
    nums[q]=nums[j];
    nums[j]=val;
    return j;
}

void QuickSort(int nums[],int n)
{
    QuickSortR(nums,0,n-1);
}
```



