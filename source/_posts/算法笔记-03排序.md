---
title: 算法笔记-03排序
date: 2019-11-16 19:42:41
categories: 数据结构与算法学习笔记
tags: [排序]
keyword: 排序
---

##  排序算法

### 总结表

| 排序算法 |   平均时间复杂度   |     最好情况     |     最坏情况     | 空间复杂度 | 稳定性 | 排序方式  |
| :------: | :----------------: | :--------------: | :--------------: | :--------: | :----: | :-------: |
| 冒泡排序 |  O(n<sup>2</sup>)  |       O(n)       | O(n<sup>2</sup>) |    O(1)    |  稳定  | in-place  |
| 选择排序 |  O(n<sup>2</sup>)  | O(n<sup>2</sup>) | O(n<sup>2</sup>) |    O(1)    | 不稳定 | in-place  |
| 插入排序 |  O(n<sup>2</sup>)  |       O(n)       | O(n<sup>2</sup>) |    O(1)    |  稳定  | in-place  |
| 希尔排序 | O(n<sup>1.3</sup>) |       O(n)       | O(n<sup>2</sup>) |    O(1)    | 不稳定 | in-place  |
| 归并排序 |      O(nlogn)      |     O(nlogn)     |     O(nlogn)     |    O(n)    |  稳定  | out-place |
| 快速排序 |      O(nlogn)      |     O(nlogn)     | O(n<sup>2</sup>) |  O(logn)   | 不稳定 | in-place  |
|  堆排序  |      O(nlogn)      |     O(nlogn)     |     O(nlogn)     |    O(1)    | 不稳定 | in-place  |
|  桶排序  |       O(n+k)       |      O(n+k)      | O(n<sup>2</sup>) |   O(n+k)   |  稳定  | out-place |
| 计数排序 |       O(n+k)       |      O(n+k)      |      O(n+k)      |    O(k)    |  稳定  | out-place |
| 基数排序 |       O(n*k)       |      O(n*k)      |      O(n*k)      |   O(n+k)   |  稳定  | out-place |

  注：排序方式in-place意思是原地排序，与内部排序和外部排序(数据存储在外部磁盘中，无法一次全部加载到内存中)的概念不同。

**排序的本质就是消除逆序数**，如果采用"交换相邻元素"的办法来消除逆序，每次正好只消除一个，因此必须执行O(n<sup>2</sup>)的交换次数，这就是冒泡、插入等算法只能到平方级的原因。**基于交换元素的排序想要突破这个下界，必须执行一些比较、交换相隔比较远的元素，使得一次交换能消除多个逆序**，像希尔、快排、堆排等算法都是交换比较远的元素，只不过规则各不相同罢了。

<br>

### 各类排序算法实现

#### **冒泡排序**

**基本思想**：每一趟逐次比较相邻元素，总是把值大的元素(泡泡)往上冒，一趟可以放好一个元素的位置，执行n趟即可。加入一个flag标志(如果某一趟没有执行交换操作则说明已经有序，即可提前结束排序)可以优化最好情况的时间复杂度到O(n)。

C++实现：

```c++
// 1.冒泡排序
// 时间复杂度:最好-O(n),最坏-O(n^2)，平均-O(n^2)  
// 空间复杂度:O(1)
// 稳定排序
void BubbleSort(int nums[],int n)
{
    bool flag;
    for(int i=0;i<n;i++)
    {
        flag=true;
        for(int j=0;j<n-i-1;j++)
        {
            if(nums[j]>nums[j+1])
            {
                flag=false;
                int temp = nums[j];
                nums[j]=nums[j+1];
                nums[j+1]=temp;
            }
        }
        if(flag)
            break;
    }
}
```

Python实现：

```python
def BubbleSort(data):
    length = len(data)
    for i in range(length):
        for j in range(length-i-1):
            if data[j]>data[j+1]:
                data[j+1],data[j] = data[j],data[j+1]
```

<br>

<!--more-->

#### **选择排序**

**基本思想**：每次从未排序区间选择一个最小的元素放到已排序区间

 C++实现：

```c++
// 2.选择排序
// 时间复杂度:最好-O(n^2),最坏-O(n^2)，平均-O(n^2)  
// 空间复杂度:O(1)
// 不稳定排序
void SelectSort(int nums[],int n)
{
    for(int i=0;i<n;i++)
    {
        int tempMin=nums[i],index=i;
        for(int j=i+1;j<n;j++)
        {
            if(nums[j]<tempMin)
            {
                tempMin=nums[j];
                index=j;
            }
        }
        nums[index]=nums[i];
        nums[i]=tempMin;
    }
}
```

Python实现：

```python
def SelectSort(data):
    length=len(data)
    for i in range(length):
        tempMin,index=data[i],i
        for j in range(i+1,length):
            if data[j]<tempMin:
                tempMin=data[j]
                index=j
        data[index]=data[i]
        data[i]=tempMin
```

<br>

#### 希尔排序

也称**递减增量**排序算法，是插入排序的一种更高效的改进版本。最坏情况下的时间复杂度随**步长序列**的不同而不同，下限是O(nlog<sup>2</sup>n)。

**基本思想**：每次将具有**相同间隔的数分为一组，分别进行插入排序**，希尔排序的实质就是分组的插入排序

C++实现：

```c++
// 6.希尔排序
// 时间复杂度：平均O(n^1.3)，最好O(n)，最坏O(n^2)
// 空间复杂度：O(1)
// 稳定性：不稳定
void ShellSort(int nums[],int n)
{
    int gap=n/2;
    while (gap>=1)
    {
        for(int i=gap;i<n;i++)
        {
            for(int j=i;j-gap>=0&&nums[j]<nums[j-gap];j-=gap)
                swap(nums[j],nums[j-gap]);
        }
        gap/=2;
    }
}
```



<br>

#### 插入排序

**基本思想**：每次从未排序区间往已排序区间插入元素

C++实现：

```c++
// 2.插入排序
// 时间复杂度:最好-O(n),最坏-O(n^2)，平均-O(n^2)  
// 空间复杂度:O(1)
// 稳定排序
void InsertSort(int nums[],int n) 
{
    // 初始化：假定一个元素是已排序区间，之后的元素为未排序区间
    for(int i=1;i<n;i++)
    {
        int tmp = nums[i],j;
        for(j=i-1;j>=0;j--)
        {
            if(tmp>=nums[j])
                break;
            else
                nums[j+1]=nums[j];
        }
        nums[j+1]=tmp;
    }
}
```

Python实现：

```python
def InsertSort(data):
    length=len(data)
    for i in range(1,length):
        temp=data[i]
        for j in range(i-1,-1,-1):
            if temp>data[j]:
                break
            else:
                data[j+1]=data[j]
        data[j+1]=temp
```

<br>

#### 归并排序

**基本思想**：利用分治的思想，自底向上，关键在于归并(Merge)操作。

C++实现：

```c++
// 4.归并排序
// 时间复杂度：所有情况下都是O(nlogn)
// 空间复杂度：每次归并需要开辟一个临时数组然后释放，所以是O(n)
// 稳定性：稳定
// 递推式：sort(p,q) = merge(sort(p,r),sort(r+1,q))  边界条件:p>=q
void MergeSortR(int nums[],int p,int q)
{
    if(p>=q)
        return;
    int r = (p+q)/2;
    MergeSortR(nums,p,r);
    MergeSortR(nums,r+1,q);
    Merge(nums,p,q,r);
}

//把nums[p...r]和nums[r+1,q]合并到nums[p...q]
void Merge(int nums[],int p,int q,int r)
{
    int n=q-p+1,i=p,j=r+1,k=0;
    int *tmp = new int[n];
    //二路归并
    while (i<=r&&j<=q)
    {
        if(nums[i]<=nums[j])
            tmp[k++]=nums[i++];
        else
            tmp[k++]=nums[j++];
    }
    //把其中一个剩余的数组中的数搬到临时数组中
    int start=i,end=r;
    if(j<=q)
    {
       start=j;
       end=q;  
    }
    while (start<=end)
        tmp[k++]=nums[start++];
    //将tmp临时数组拷贝回nums数组
    for(int t=0;t<=q-p;t++)
        nums[p+t]=tmp[t];
    delete tmp;
}

void MergeSort(int nums[],int n)
{
    MergeSortR(nums,0,n-1);
}
```

<br>

#### 快速排序

**基本思想**：也利用了分治思想，自顶向下，关键在于分区(Partition)操作。

补充：为了避免快排退化到O(n<sup>2</sup>)，选择分区元素可以采取不同的策略：1.三点取中法 2.随机选择法

C++实现:

```c++
// 5.快速排序
// 时间复杂度：最坏(数组逆序):O(n^2),平均(大多数情况):O(nlogn)
// 空间复杂度：O(1)
// 稳定性：不稳定
// 递推式：sort(A[p..q]) = sort(A[p..r-1])+sort(A[r+1..q]) 终止条件:p>=q
void QuickSortR(int nums[],int p,int q)
{
    if(p>=q)
        return;
    int r=Partition(nums,p,q);
    QuickSortR(nums,p,r-1);
    QuickSortR(nums,r+1,q);
}

int Partition(int nums[],int p,int q)
{
    int val=nums[q],i=p,j=p;
    for(;i<q;i++)
    {
        if(nums[i]<=val)
        {
            int temp=nums[i];
            nums[i]=nums[j];
            nums[j]=temp;
            j++;
        }
    }
    nums[q]=nums[j];
    nums[j]=val;
    return j;
}

void QuickSort(int nums[],int n)
{
    QuickSortR(nums,0,n-1);
}
```

<br>

#### 桶排序

**基本思想**：将n个数据根据数据范围逐一放入m个桶中(桶之间是有序的)，再对桶内进行排序(如使用快排)，最后遍历桶逐一输出即可。

**时间复杂度分析**：每个桶里有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(k\*logk)，m个桶的时间复杂度就是O(m\*k\*logk)，又因为k=n/m，替换掉k得到O(n\*log(n/m))，当m接近n时，log(n/m)是一个很小的常量可以忽略。所以桶排序的时间复杂度接近O(n)。极端情况下，如果数据都被划到一个桶里，就退化为O(nlogn)的算法了。

应用场景：桶排序比较适合应用在外部排序中。比如数据量太大无法一次全部加载到内存中，那么可以根据数据范围创建一定数量的桶。扫描文件将数据放到相应的桶中，然后将每个桶放到内存中进行快速排序。最后再按照桶的顺序依次将数据写入一个文件就可以了。

<br>

#### 计数排序

基本思想：计数排序实际上是桶排序的一种特殊情况，每个桶里的数据都是相同的，省掉了桶内排序的时间。计数排序的一般步骤为：1.确定数组中数据的范围(最大值)&nbsp;2.遍历数据计算每个元素的个数并存放到计数数组中&nbsp;3.对计数数组依次累加，此时存放的是小于等于某值的元素个数。&nbsp;4.根据计数数组将原数据放到合适的位置

应用场景：考生成绩排序

<br>

#### 基数排序

基本思想：从低位到高位根据每一位来排序(用桶排序或计数排序)。对数据要求比较高：可以独立分割出位来进行比较，而且位之间有递进关系，每一位的数据范围也不能太大，要用稳定的线性排序算法来排序。所以如果有k位的话，时间复杂度就是O(k*n);

应用场景：电话号码排序，英文单词排序