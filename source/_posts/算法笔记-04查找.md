---
title: 算法笔记-04查找
date: 2019-11-17 15:52:56
categories: 数据结构与算法学习笔记
tags: [查找]
keyword: 查找
---

## 二分查找

### 局限性

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分查找是非常高效的算法，时间复杂度为O(logn)。但存在一定的**局限性**：

1. 二分查找依赖**顺序表**结构，比如数组
2. 二分查找适用于已经**有序**的数据
3. 二分查找适用于插入和删除操作不频繁，一次排序多次查找的场景中，不适合动态变化的数据集合
4. 数据量太小或数据量太大(如：1GB，这时就需要1GB的连续内存空间，比较难分配)都不适合

<br>

### 二分查找的变形问题

- 查找第一个值等于给定值的元素
- 查找最后一个值等于给定值的元素
- 查找第一个大于等于给定值的元素
- 查找最后一个小于等于给定值的元素

注意：变形问题代码很容易写错，一定要理解后亲手撸一遍代码～

<br>

#### 代码实现

1.基本形态

```c++
// 二分查找：在互不相同的一组有序数中查找给定值元素(最基本的形态)
int BinarySearch(int nums[],int val,int lo,int hi)
{
    if(lo>hi)
        return -1;
    int mid = lo + ((hi-lo)>>1);
    if(val==nums[mid])
        return mid;
    else if(val<nums[mid])
        hi = mid-1;
    else if(val>nums[mid])
        lo = mid+1;
    return BinarySearch(nums,val,lo,hi);
}
```

<br>

2.查找第一个值等于给定值的元素

```c++
// 二分查找变体1：在一组有序数中,查找第一个等于给定值的元素
int FindFirstEquVal(int nums[],int val,int lo,int hi)
{
    if(lo>hi)
        return -1;
    int mid = lo + ((hi-lo)>>1);
    if(val<nums[mid])
        hi = mid-1;
    else if(val>nums[mid])
        lo = mid+1;
    else
    {
        if(mid==lo||nums[mid-1]!=val)
            return mid;
        else
            hi = mid-1;
    }
    return FindFirstEquVal(nums,val,lo,hi);
}
```

<br>

<!--more-->

3.查找最后一个值等于给定值的元素

```c++
// 二分查找变体2：在一组有序数中,查找最后一个等于给定值的元素
int FindLastEquVal(int nums[],int val,int lo,int hi)
{
    if(lo>hi)
        return -1;
    int mid = lo + ((hi-lo)>>1);
    if(val<nums[mid])
        hi = mid-1;
    else if(val>nums[mid])
        lo = mid+1;
    else
    {
        if(mid==hi||nums[mid+1]!=val)
            return mid;
        else
            lo = mid+1;
    }
    return FindFirstEquVal(nums,val,lo,hi); 
}
```

<br>

4.查找第一个大于等于给定值的元素

```c++
// 二分查找变体3：在一组有序数中,查找第一个大于等于给定值的元素
int FindFirstGreatThanVal(int nums[],int val,int lo,int hi)
{
    if(lo>hi)
        return -1;
    int mid = lo + ((hi-lo)>>1);
    if(val>nums[mid])
        lo = mid+1;
    else
    {
        if(mid==lo||nums[mid-1]<val)
            return mid;
        else
            hi = mid-1; 
    }
    return FindFirstGreatThanVal(nums,val,lo,hi);
}
```

<br>

5.查找最后一个小于等于给定值的元素

```c++
// 二分查找变体4：在一组有序数中,查找最后一个小于等于给定值的元素
int FindLastSmallThanVal(int nums[],int val,int lo,int hi)
{
    if(lo>hi)
        return -1;
    int mid = lo + ((hi-lo)>>1);
    if(val<nums[mid])
        hi = mid-1;
    else
    {
        if(mid==hi||nums[mid+1]>val)
            return mid;
        else
            lo = mid+1;
    }
    return FindLastSmallThanVal(nums,val,lo,hi);
}
```

