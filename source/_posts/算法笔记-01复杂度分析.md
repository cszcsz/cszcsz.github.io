---
title: 算法笔记-01复杂度分析
date: 2019-10-24 10:31:55
categories: 数据结构与算法学习笔记
tags: [复杂度分析]
keyword: 复杂度分析
---

## 1. 为什么要做这个笔记

​    最近开始重新学习数据结构与算法知识，俗话说：读书白遍，其义自见，要想真正学好数据结构与算法，必须要经过不断地反复锤炼才行，做笔记是一个消化知识的过程，在脑海中将学到的知识重演一遍并以自己的话总结出来，这样自身的内功才能得以提升。



## 2、时间复杂度

#### 2.1 什么是时间复杂度

- 时间复杂度描述的是算法的**执行时间随问题规模增长变化的趋势**      
  

#### 2.2 为什么要引入时间复杂度

- 事前对算法进行分析，指导我们写出高效的程序
- 提高我们的逻辑思维能力和分析问题的能力
- 与性能测试并不冲突，性能测试更为具体，而时间复杂度分析的是随问题规模增长下程序运行时间的变化趋势
  

#### 2.3 怎样判断一个程序的时间复杂度（重点）

1. **单段代码看高频**：看最内层代码的执行次数（如：循环）
2. **多段代码取最大**：只考虑最高阶的项，低阶项、系数、常数都可以忽略（加法法则）
3. **嵌套代码求乘积**：时间复杂度为内层和外层的乘积（乘法法则）
4. **多个规模求加法**：时间复杂度为其求和的结果（如：O(n+m)）

<!--more-->


#### 2.4 常见的时间复杂度

#####     O(1)<O(logn)<O(n)<O(nlogn)<O(n<sup>2</sup>)<O(n<sup>3</sup>)<O(2<sup>n</sup>)<O(n!)

![2.jpg](https://i.loli.net/2019/10/24/hWDm6Ylsf3bMu7j.jpg)

注意：对于对数阶，由于换底公式和可以省略系数，所以不管以2为底还是以3为底，我们都记作O(logn)


#### 2.5 最好时间复杂度、最坏时间复杂度、平均时间复杂度、均摊时间复杂度

​    为了**更准确的描述**算法的复杂度，引入以上四个概念。比如下面这段代码：

```java
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

最好时间复杂度：O(1)，最坏时间复杂度：O(n)，平均时间复杂度：O(1)，均摊时间复杂度：O(1)

- ##### 如何比较平均时间复杂度和均摊时间复杂度？

  1. 平均时间复杂度：代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。
  2. 均摊时间复杂度：两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。

  **总结：平均和均摊基本是一个概念，均摊是平均的一种特殊情况，可以凭感觉分析是O(1)还是O(n)，如果出现O(1)的次数远大于出现O(n)的次数，那么平均和均摊复杂度就是O(1)**  



## 2、空间复杂度

- 空间复杂度较为简单。与时间复杂度类似，空间复杂度全称是渐进空间复杂度，描述的是算法的**存储空间随问题规模增长的变化趋势**。常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup>)。

